// Prompt: .github/prompts/recorder_scan_tc_test.go.prompt.md
// Model: Claude Sonnet 4.5
package recorder

import "time"

var RecorderScanTestCases = []*RecorderScanTestCase{
	{
		Name:             "HttpResponseError",
		Description:      "HTTP client returns an error, encoder should be closed and scan should return false but continue running",
		Scenario:         TEST_PARSER_SCAN_SCENARIO_HTTP_RESPONSE_ERROR,
		StartTs:          time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:   true,
		WantEncoderCalls: []string{},
	},
	{
		Name:             "HttpResponseNotOk",
		Description:      "HTTP response status is not OK (404), should be treated as parse error, encoder closed",
		Scenario:         TEST_PARSER_SCAN_SCENARIO_HTTP_RESPONSE_NOT_OK_ERROR,
		StartTs:          time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:   true,
		WantEncoderCalls: []string{},
	},
	{
		Name:             "NonJsonContent",
		Description:      "HTTP response has non-JSON content type, should be fatal error stopping the recorder",
		Scenario:         TEST_PARSER_SCAN_SCENARIO_HTTP_NON_JSON_CONTENT_ERROR,
		StartTs:          time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:   false,
		WantEncoderCalls: []string{},
	},
	{
		Name:             "ParseError",
		Description:      "Parser returns error, encoder should be closed, parse error gauge incremented",
		Scenario:         TEST_PARSER_SCAN_SCENARIO_PARSE_ERROR,
		StartTs:          time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:   true,
		WantEncoderCalls: []string{},
	},
	{
		Name:                "ParseErrorBelowThreshold",
		Description:         "Parse error gauge is below threshold, scan continues despite error",
		Scenario:            TEST_PARSER_SCAN_SCENARIO_PARSE_ERROR,
		ParseErrorGauge:     2,
		ParseErrorThreshold: 5,
		StartTs:             time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:      true,
		WantEncoderCalls:    []string{},
	},
	{
		Name:                "ParseErrorReachesThreshold",
		Description:         "Parse error gauge reaches threshold, should be fatal error stopping the recorder",
		Scenario:            TEST_PARSER_SCAN_SCENARIO_PARSE_ERROR,
		ParseErrorGauge:     4,
		ParseErrorThreshold: 5,
		StartTs:             time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		WantScanRetVal:      false,
		WantEncoderCalls:    []string{},
	},
	{
		Name:            "RecordError",
		Description:     "Recordable parser returns error during Record(), encoder should be closed, fatal error",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_RECORD_ERROR,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  false,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
		},
	},
	{
		Name:            "SuccessfulScanNoFlush",
		Description:     "Successful scan without flush (flush interval disabled), parse error gauge decremented",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_NONE,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
		},
	},
	{
		Name:            "AlwaysFlush",
		Description:     "Flush interval is 0, encoder should flush after every scan",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_ALWAYS_FLUSH,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:            "IntervalFlush",
		Description:     "Flush interval exceeded, encoder should flush and update lastFlushTs",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_INTERVAL_FLUSH,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:            "NewEncoderFlush",
		Description:     "First scan with new encoder triggers flush to create info file",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_NEW_ENCODER_FLUSH,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:             "NewEncoderError",
		Description:      "New encoder creation fails, should be fatal error stopping the recorder",
		Scenario:         TEST_PARSER_SCAN_SCENARIO_NEW_ENCODER_FLUSH,
		NewEncoderErr:    true,
		ScanInInstCount:  10,
		ScanInVarCount:   50,
		StartTs:          time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:     100 * time.Millisecond,
		WantScanRetVal:   false,
		WantEncoderCalls: []string{},
	},
	{
		Name:            "Checkpoint",
		Description:     "Checkpoint interval exceeded, encoder should checkpoint before recording data",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_CHECKPOINT,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"Checkpoint(2024-01-15 10:30:00 +0000 UTC)",
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
		},
	},
	{
		Name:            "IntervalRollover",
		Description:     "Rollover interval exceeded, encoder should close and new one created with flush",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_INTERVAL_ROLLOVER,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:            "MidnightRollover",
		Description:     "Midnight rollover triggered, encoder should close and new one created for new day",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_MIDNIGHT_ROLLOVER,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 16, 0, 0, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-16 00:00:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:            "ProcessChanged",
		Description:     "Process change detected, encoder should close and new one created with full record",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_PROCESS_CHANGED,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
			"Flush()",
		},
	},
	{
		Name:              "CompressedResponse",
		Description:       "HTTP response with deflate compression is properly decompressed and processed",
		Scenario:          TEST_PARSER_SCAN_SCENARIO_NONE,
		HttpContentLength: 500,
		ScanInInstCount:   10,
		ScanInVarCount:    50,
		OutNumVarCount:    45,
		StartTs:           time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:      100 * time.Millisecond,
		WantScanRetVal:    true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(500, 10, 50, 45)",
			"DurationUsec(100ms)",
		},
	},
	{
		Name:                "ParseErrorGaugeDecrement",
		Description:         "Successful scan decrements parse error gauge, demonstrating recovery from errors",
		Scenario:            TEST_PARSER_SCAN_SCENARIO_NONE,
		ParseErrorGauge:     3,
		ParseErrorThreshold: 5,
		ScanInInstCount:     10,
		ScanInVarCount:      50,
		OutNumVarCount:      45,
		StartTs:             time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:        100 * time.Millisecond,
		WantScanRetVal:      true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
		},
	},
	{
		Name:            "CurrIndexFlip",
		Description:     "After successful scan, current index should be flipped for next scan comparison",
		Scenario:        TEST_PARSER_SCAN_SCENARIO_NONE,
		ScanInInstCount: 10,
		ScanInVarCount:  50,
		OutNumVarCount:  45,
		CurrIndex:       0,
		StartTs:         time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		ScanDuration:    100 * time.Millisecond,
		WantScanRetVal:  true,
		WantEncoderCalls: []string{
			"TimestampUsec(2024-01-15 10:30:00 +0000 UTC)",
			"ScanTally(0, 10, 50, 45)",
			"DurationUsec(100ms)",
		},
	},
}
